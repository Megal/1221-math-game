local speed = 196
local tile_size = 64
debugger = require('libs.debugger')
debugger.start()

function init(self)
    msg.post(".", "acquire_input_focus")
    self.dir = vmath.vector3()
    self.current_anim = nil
    self.move_remains = 0
end

function normExceed(vec) 
    if vmath.length_sqr(vec) > 1 then
        return vmath.normalize(vec)
    else 
        return vec
    end
end

function update(self, dt)
    self.dir = normExceed(self.dir)
    local p = go.get_position()
    local step = math.min(speed * dt, self.move_remains)
    
    -- go.set_position(p + self.dir * step)
    
    local accel = self.dir * step * speed
    pprint("acceleration = " .. accel)
    pprint("step = " .. step)
    pprint(nearest_tile_center(p))

    -- local existingForce = go.get("astronaut#collisionobject")
    if step > 1e-9 then
        msg.post("astronaut#collisionobject", "apply_force", { force = accel, position = p })
    else
    --     local norm_tile_center_vector = normExceed( nearest_tile_center(p) - p )
    --     go.set_position(p + norm_tile_center_vector * speed * dt)
    end
    self.move_remains = self.move_remains - step
    
    -- animate the astronaut

    local anim = hash("idle")

    if self.dir.x > 0 then
        anim = hash("right")
    elseif self.dir.x < 0 then
        anim = hash("left")
    elseif self.dir.y > 0 then
        anim = hash("back")
    elseif self.dir.y < 0 then
        anim = hash("front")
    end

    if anim ~= self.current_anim then
        msg.post("#sprite", "play_animation", { id = anim })
        self.current_anim = anim
    end

    -- done animating
    if self.move_remains < 1e-9 then
        self.dir = vmath.vector3()
        pprint(go.get_position())
    end
end

function on_input(self, action_id, action)
    if self.move_remains > 1e-9 then return end
    self.move_remains = tile_size

    if action_id == hash("front") then
        self.dir.y = -1
    elseif action_id == hash("back") then
        self.dir.y = 1
    elseif action_id == hash("left") then
        self.dir.x = -1
    elseif action_id == hash("right") then
        self.dir.x = 1
    end
end

function nearest_tile_center(position)
    local reminderX = position.x - math.fmod(position.x, tile_size) + tile_size * 0
    local reminderY = position.y - math.fmod(position.y, tile_size) + tile_size * 0

    return vmath.vector3(reminderX, reminderY, position.z)
end

function on_message(self, message_id, message)
    if message_id == hash("collision_response") then
        -- take action
        pprint("I collided with" .. message.other_group)
    end
end